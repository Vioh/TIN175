
/********************************************************************************
The goal of the Planner module is to take the interpetation(s) produced by the 
Interpreter module and to plan a sequence of actions for the robot to put the world 
into a state compatible with the user's command, i.e. to achieve what the user wanted.
********************************************************************************/
import {WorldState} from "./World";
import {Successor, Graph, SearchResult} from "./Graph";
import {aStarSearch} from "./AStarSearch";
import {ShrdliteResult, DNFFormula, Conjunction, Literal, SimpleObject} from "./Types";

/** 
 * Top-level driver for the Planner. 
 * It calls `makePlan` for each given interpretation generated by the Interpreter.
 * @param interpretations: List of possible interpretations.
 * @param world: The current state of the world.
 * @returns: List of planner results, which are the interpretation results augmented with plans. 
 *           Each plan is represented by a list of strings.
 *           If there's a planning error, it throws an error with a string description.
 */
export function plan(interpretations : ShrdliteResult[], world : WorldState) : ShrdliteResult[] {
    var errors : string[] = [];
    var plans : ShrdliteResult[] = [];
    var planner : Planner = new Planner(world);
    for (var result of interpretations) {
        try {
            var theplan : string[] = planner.makePlan(result.interpretation);
        } catch(err) {
            errors.push(err);
            continue;
        }
        result.plan = theplan;
        if (result.plan.length == 0) {
            result.plan.push("The interpretation is already true!");
        }
        plans.push(result);
    }
    if (plans.length == 0) {
        // merge all errors into one
        throw errors.join(" ; ");
    }
    return plans;
}

// ===============================================================================================
// ===============================================================================================
// ===============================================================================================

class ShrdliteGraph implements Graph<ShrdliteNode> {
    compareNodes(a : ShrdliteNode, b : ShrdliteNode) : number {
        return a.compareTo(b);
    }
    successors(current : ShrdliteNode) : Successor<ShrdliteNode>[] {
        let outputs : Successor<ShrdliteNode>[] = [];
        let actions = ["l","r","p","d"]; // left, right, pick, drop
        actions.forEach((action) => {
            let next : ShrdliteNode | null = current.neighbor(action);
            if(next) outputs.push({"action": action, "child": next, "cost": 1});
        });
        return outputs;
    }
}

// ===============================================================================================
// ===============================================================================================
// ===============================================================================================

class ShrdliteNode {
    public id : string;
    public state : WorldState;
    private readonly objects : {[s:string]: SimpleObject};

    constructor(state : WorldState, objects : {[s:string]: SimpleObject}) {
        this.state = state;
        this.id = `${state.arm},${state.holding},${this.stringify(state.stacks)}`;
    }
    public toString() : string {
        return this.id;
    }
    public compareTo(other : ShrdliteNode) {
        return this.id.localeCompare(other.id);
    }
    public neighbor(action : string) : ShrdliteNode | null {
        let stacks = this.state.stacks;
        let holding = this.state.holding;
        let xpos = this.state.arm;
        let ypos = stacks[xpos].length - 1;

        if(action == 'l') {
            if(xpos == 0) return null;
            let newState = this.clone(this.state);
            --newState.arm; // go left one step
            return new ShrdliteNode(newState, this.state.objects);
        }
        if(action == 'r') {
            if(xpos == stacks.length-1) return null;
            let newState = this.clone(this.state);
            ++newState.arm; // go right one step
            return new ShrdliteNode(newState, this.state.objects);
        }
        if(action == 'p') {
            if(holding || ypos == -1) return null;
            let newState = this.clone(this.state);
            newState.holding = newState.stacks[xpos][ypos];
            newState.stacks[xpos].splice(ypos, 1);
            return new ShrdliteNode(newState, this.state.objects);
        }
        if(action == 'd') {
            let dest = (ypos == -1)? "floor" : stacks[xpos][ypos];
            if(!holding || this.isValidDrop(holding, dest)) return null;
            let newState = this.clone(this.state);
            if(!newState.holding) return null; // dummy check to pass compiler's type checker
            newState.stacks[xpos].push(newState.holding);
            newState.holding = null;
            return new ShrdliteNode(newState, this.state.objects);
        }
        return null;
    }
    private stringify(stacks : string[][]) : string {
        let output : string[] = [];
        for(let stack of stacks)
            output.push(`[${stack.join(",")}]`);
        return `[${output.join(",")}]`;
    }
    private clone(state : WorldState) : WorldState {
        return {
            "stacks": JSON.parse(JSON.stringify(state.stacks)),
            "holding": state.holding,
            "arm": state.arm,
            "examples": [], // examples are not needed for the planer
            "objects": {},  // object definitions are not needed for the planer
        };
    }
    private isValidDrop(obj1 : string, obj2 : string) : boolean {
        let floor : SimpleObject = new SimpleObject("floor", null, null);
        let a : SimpleObject = this.objects[obj1];
        let b : SimpleObject = (obj2 == "floor")? floor : this.objects[obj2];

        function memberOf(needle : string, haystack : string[]) : boolean {
            return haystack.indexOf(needle) > -1;
        }
        // Special case => anything can be dropped on the floor.
        if(b.form == "floor") return true;
        // Nothing can be dropped on a ball.
        if(b.form == "ball") return false;
        // A ball can't be dropped on anything else other than a box or the floor.
        if(a.form == "ball" && b.form != "box") return false;
        // A pyramid/plank/box cannot be dropped into a box of the same size.
        if(memberOf(a.form, ["pyramid","plank","box"]) && b.form == "box" && a.size == b.size) return false;
        // A large object cannot be dropped on a small object.
        if(a.size == "large" && b.size == "small") return false;

        if(a.form == "box" && memberOf(b.form, ["pyramid","brick"])) {
            // A small box cannot be dropped on a small brick/pyramid.
            if(a.size == "small" && b.size == "small") return false;
            // A large box cannot be dropped on a large pyramid.
            if(a.size == "large" && b.size == "large" && b.form == "pyramid") return false;
        }
        return true; 
    }
}

// ===============================================================================================
// ===============================================================================================
// ===============================================================================================

/** Returns the x-y coordinate of an object in the stacks. */
function coordinate(obj : string, state : WorldState) : {x : number, y : number} {
    for(let i : number = 0; i < state.stacks.length; ++i) {
        let j : number = state.stacks[i].indexOf(obj);
        if(j > -1) return {"x" : i, "y" : j};
    }
    return {"x" : -1, "y" : -1}; // this is for the floor
}

/** Returns a specialized goal test for a ShrdliteNode */
function goalTest(interpretation : DNFFormula) : (node : ShrdliteNode) => boolean {
    return function(node : ShrdliteNode) {
        for(let conj of interpretation.conjuncts)
            if(isTrueConj(conj, node.state)) return true;
        return false;
    }
    function isTrueConj(conj : Conjunction, state : WorldState) : boolean {
        for(let lit of conj.literals)
            if(!isTrueLiteral(lit, state)) return false;
        return true;
    }
    function isTrueLiteral(lit : Literal, state : WorldState) : boolean {
        if(lit.args.length == 1) {
            if(lit.relation == "holding" && lit.args[0] == state.holding) return true;
        }
        else if(lit.args.length == 2) {
            return checkBinaryRelation(lit, state);
        }
        return false;
    }
    function checkBinaryRelation(lit : Literal, state : WorldState) : boolean {
        let rel = lit.relation;
        let coorA = coordinate(lit.args[0], state); // coordinate of object A
        let coorB = coordinate(lit.args[1], state); // coordinate of object B
        
        // Case 1: A and B are on the same stack of objects.
        if(lit.args[1] == "floor" || coorA.x == coorB.x) {
            if(rel == "ontop"  && coorA.y == coorB.y + 1) return true;
            if(rel == "inside" && coorA.y == coorB.y + 1) return true;
            if(rel == "above"  && coorA.y > coorB.y) return true;
            if(rel == "under"  && coorA.y < coorB.y) return true;
        } 
        // Case 2: a and b are on 2 different stacks of objects
        else {
            if(rel == "beside"  && Math.abs(coorA.x - coorB.x) == 1) return true;
            if(rel == "leftof"  && coorA.x < coorB.x) return true;
            if(rel == "rightof" && coorA.x > coorB.x) return true;
        }
        return false;
    }
}

// ===============================================================================================
// ===============================================================================================
// ===============================================================================================

class Planner {
    constructor(
        private world : WorldState
    ) {}

    /** 
     * The core planner method.
     * @param interpretation: The logical interpretation of the user's desired goal. 
     * @returns: A plan, represented by a list of strings.
     *           If there's a planning error, it throws an error with a string description.
     */
    makePlan(interpretation : DNFFormula) : string[] {
        var state = this.world;
        var plan : string[] = [];

        // Select a random nonempty stack
        do {
            var pickstack = Math.floor(Math.random() * state.stacks.length);
        } while (state.stacks[pickstack].length == 0);

        // First move the arm to the selected stack
        if (pickstack < state.arm) {
            plan.push("Moving left to stack " + pickstack);
            for (var i = state.arm; i > pickstack; i--) {
                plan.push("l");
            }
        } else if (pickstack > state.arm) {
            plan.push("Moving right to stack " + pickstack);
            for (var i = state.arm; i < pickstack; i++) {
                plan.push("r");
            }
        }
        // Then pick up the topmost object in the selected stack
        var obj = state.stacks[pickstack][state.stacks[pickstack].length-1];
        plan.push("Picking up the " + state.objects[obj].form,
                  "p");

        if (pickstack > 0) {
            // Then move the arm to the leftmost stack
            plan.push("Moving as far left as possible");
            for (var i = pickstack; i > 0; i--) {
                plan.push("l");
            }
        }
        // Select a random destination stack (either empty or the original pickup stack)
        do {
            var dropstack = Math.floor(Math.random() * state.stacks.length);
        } while (!(state.stacks[dropstack].length == 0 || dropstack == pickstack));

        if (dropstack > 0) {
            // Then move the arm to the destination stack
            plan.push("Moving right to the destination stack " + dropstack);
            for (var i = 0; i < dropstack; i++) {
                plan.push("r");
            }
        }
        // Finally put the object down again
        plan.push("Dropping the " + state.objects[obj].form,
                  "d");

        return plan;
    }
}

// TODO: Throw errors in plannner at appropriae places!