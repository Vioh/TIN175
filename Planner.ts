
/********************************************************************************
The goal of the Planner module is to take the interpetation(s) produced by the 
Interpreter module and to plan a sequence of actions for the robot to put the world 
into a state compatible with the user's command, i.e. to achieve what the user wanted.
********************************************************************************/
import {WorldState} from "./World";
import {Successor, Graph, SearchResult} from "./Graph";
import {aStarSearch} from "./AStarSearch";
import {ShrdliteResult, DNFFormula, Literal, SimpleObject} from "./Types";

/** 
 * Top-level driver for the Planner. 
 * It calls `makePlan` for each given interpretation generated by the Interpreter.
 * @param interpretations: List of possible interpretations.
 * @param world: The current state of the world.
 * @returns: List of planner results, which are the interpretation results augmented with plans. 
 *           Each plan is represented by a list of strings.
 *           If there's a planning error, it throws an error with a string description.
 */
export function plan(interpretations : ShrdliteResult[], world : WorldState) : ShrdliteResult[] {
    var errors : string[] = [];
    var plans : ShrdliteResult[] = [];
    var planner : Planner = new Planner(world);
    for (var result of interpretations) {
        try {
            var theplan : string[] = planner.makePlan(result.interpretation);
        } catch(err) {
            errors.push(err);
            continue;
        }
        result.plan = theplan;
        if (result.plan.length == 0) {
            result.plan.push("The interpretation is already true!");
        }
        plans.push(result);
    }
    if (plans.length == 0) {
        // merge all errors into one
        throw errors.join(" ; ");
    }
    return plans;
}

// ===============================================================================================
// ===============================================================================================
// ===============================================================================================

class ShrdliteGraph implements Graph<ShrdliteNode> {
    compareNodes(a : ShrdliteNode, b : ShrdliteNode) : number {
        return a.compareTo(b);
    }
    successors(current : ShrdliteNode) : Successor<ShrdliteNode>[] {
        let outputs = [];
        let actions = ["l","r","p","d"]; // left, right, pick, drop
        actions.forEach((action) => {
            let next : ShrdliteNode | null = current.neighbor(action);
            if(next) outputs.push({"action": action, "child": next, "cost": 1});
        });
        return outputs;
    }
}

// ===============================================================================================
// ===============================================================================================
// ===============================================================================================

class ShrdliteNode {
    public id : string;
    public state : WorldState;
    private readonly objects : {[s:string]: SimpleObject};

    constructor(state : WorldState, objects : {[s:string]: SimpleObject}) {
        this.state = state;
        this.id = `${state.arm},${state.holding},${this.stringify(state.stacks)}`;
    }
    public toString() : string {
        return this.id;
    }
    public compareTo(other : ShrdliteNode) {
        return this.id.localeCompare(other.id);
    }
    public neighbor(action : string) : ShrdliteNode | null {
        let stacks = this.state.stacks;
        let holding = this.state.holding;
        let xpos = this.state.arm;
        let ypos = stacks[xpos].length - 1;

        if(action == 'l') {
            if(xpos == 0) return null;
            let newState = this.clone(this.state);
            --newState.arm; // go left one step
            return new ShrdliteNode(newState, this.state.objects);
        }
        if(action == 'r') {
            if(xpos == stacks.length-1) return null;
            let newState = this.clone(this.state);
            ++newState.arm; // go right one step
            return new ShrdliteNode(newState, this.state.objects);
        }
        if(action == 'p') {
            if(holding || ypos == -1) return null;
            let newState = this.clone(this.state);
            newState.holding = newState.stacks[xpos][ypos];
            newState.stacks[xpos].splice(ypos, 1);
            return new ShrdliteNode(newState, this.state.objects);
        }
        if(action == 'd') {
            let dest = (ypos == -1)? "floor" : stacks[xpos][ypos];
            if(!holding || this.isValidDrop(holding, dest)) return null;
            let newState = this.clone(this.state);
            newState.stacks[xpos].push(newState.holding);
            newState.holding = null;
            return new ShrdliteNode(newState, this.state.objects);
        }
        return null;
    }
    private stringify(input) {
        if(!Array.isArray(input)) return input;
        let output = input.map(this.stringify);
        output = output.join(",");
        return `[${output}]`
    }
    private clone(state : WorldState) : WorldState {
        return {
            "stacks": JSON.parse(JSON.stringify(state.stacks)),
            "holding": state.holding,
            "arm": state.arm,
            "examples": [], // examples are not needed for the planer
            "objects": {},  // object definitions are not needed for the planer
        };
    }
    private isValidDrop(obj1 : string, obj2 : string) : boolean {
        let floor : SimpleObject = new SimpleObject("floor", null, null);
        let a : SimpleObject = this.objects[obj1];
        let b : SimpleObject = (obj2 == "floor")? floor : this.objects[obj2];

        function memberOf(needle : string, haystack : string[]) : boolean {
            return haystack.indexOf(needle) > -1;
        }
        // Special case => anything can be dropped on the floor.
        if(b.form == "floor") return true;
        // Nothing can be dropped on a ball.
        if(b.form == "ball") return false;
        // A ball can't be dropped on anything else other than a box or the floor.
        if(a.form == "ball" && b.form != "box") return false;
        // A pyramid/plank/box cannot be dropped into a box of the same size.
        if(memberOf(a.form, ["pyramid","plank","box"]) && b.form == "box" && a.size == b.size) return false;
        // A large object cannot be dropped on a small object.
        if(a.size == "large" && b.size == "small") return false;

        if(a.form == "box" && memberOf(b.form, ["pyramid","brick"])) {
            // A small box cannot be dropped on a small brick/pyramid.
            if(a.size == "small" && b.size == "small") return false;
            // A large box cannot be dropped on a large pyramid.
            if(a.size == "large" && b.size == "large" && b.form == "pyramid") return false;
        }
        return true; 
    }
}

// ===============================================================================================
// ===============================================================================================
// ===============================================================================================

class Planner {
    constructor(
        private world : WorldState
    ) {}

    /** 
     * The core planner method.
     * @param interpretation: The logical interpretation of the user's desired goal. 
     * @returns: A plan, represented by a list of strings.
     *           If there's a planning error, it throws an error with a string description.
     */
    makePlan(interpretation : DNFFormula) : string[] {
        var state = this.world;
        var plan : string[] = [];

        // Select a random nonempty stack
        do {
            var pickstack = Math.floor(Math.random() * state.stacks.length);
        } while (state.stacks[pickstack].length == 0);

        // First move the arm to the selected stack
        if (pickstack < state.arm) {
            plan.push("Moving left to stack " + pickstack);
            for (var i = state.arm; i > pickstack; i--) {
                plan.push("l");
            }
        } else if (pickstack > state.arm) {
            plan.push("Moving right to stack " + pickstack);
            for (var i = state.arm; i < pickstack; i++) {
                plan.push("r");
            }
        }
        // Then pick up the topmost object in the selected stack
        var obj = state.stacks[pickstack][state.stacks[pickstack].length-1];
        plan.push("Picking up the " + state.objects[obj].form,
                  "p");

        if (pickstack > 0) {
            // Then move the arm to the leftmost stack
            plan.push("Moving as far left as possible");
            for (var i = pickstack; i > 0; i--) {
                plan.push("l");
            }
        }
        // Select a random destination stack (either empty or the original pickup stack)
        do {
            var dropstack = Math.floor(Math.random() * state.stacks.length);
        } while (!(state.stacks[dropstack].length == 0 || dropstack == pickstack));

        if (dropstack > 0) {
            // Then move the arm to the destination stack
            plan.push("Moving right to the destination stack " + dropstack);
            for (var i = 0; i < dropstack; i++) {
                plan.push("r");
            }
        }
        // Finally put the object down again
        plan.push("Dropping the " + state.objects[obj].form,
                  "d");

        return plan;
    }
}